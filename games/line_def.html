<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>ライン・ディフェンダー</title>
    <meta name="google-adsense-account" content="ca-pub-3571574988222927">
    <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3571574988222927" crossorigin="anonymous"></script>

    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.1/css/all.min.css">
    <style>
        body { margin: 0; background: #0a0a0a; font-family: sans-serif; overflow: hidden; touch-action: none; color: #fff; }
        canvas { display: block; }
        #ui { position: absolute; top: 20px; width: 100%; text-align: center; pointer-events: none; }
        #score { font-size: 2.5rem; font-weight: bold; color: #00ffcc; text-shadow: 0 0 10px #00ffcc; }
        #overlay { position: absolute; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.85); display: flex; flex-direction: column; align-items: center; justify-content: center; z-index: 100; }
        .btn { background: #00ffcc; color: #000; border: none; padding: 15px 40px; border-radius: 30px; font-size: 1.2rem; cursor: pointer; font-weight: bold; }
        .back-link { margin-top: 20px; color: #888; text-decoration: none; }
    </style>
</head>
<body>

    <div id="ui"><div id="score">0</div></div>
    <canvas id="gameCanvas"></canvas>

    <div id="overlay">
        <h1 style="color:#00ffcc;">LINE DEFENDER</h1>
        <p>線を引いて敵の弾を跳ね返せ！</p>
        <button class="btn" onclick="startGame()">MISSION START</button>
        <a href="/" class="back-link">← 一覧に戻る</a>
    </div>

<script>
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    const scoreDisp = document.getElementById('score');
    const overlay = document.getElementById('overlay');

    let score, gameActive, enemies, lines, core;
    let isDrawing = false;
    let currentLine = [];

    function init() {
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
        score = 0;
        gameActive = false;
        enemies = [];
        lines = [];
        core = { x: canvas.width / 2, y: canvas.height / 2, r: 25 };
        scoreDisp.innerText = score;
    }

    function startGame() {
        init();
        gameActive = true;
        overlay.style.display = 'none';
        loop();
    }

    function loop() {
        if (!gameActive) return;
        ctx.fillStyle = 'rgba(10, 10, 10, 0.3)';
        ctx.fillRect(0, 0, canvas.width, canvas.height);

        // コア（守る対象）
        ctx.beginPath();
        ctx.arc(core.x, core.y, core.r, 0, Math.PI * 2);
        ctx.strokeStyle = '#00ffcc';
        ctx.lineWidth = 2;
        ctx.stroke();
        ctx.shadowBlur = 15;
        ctx.shadowColor = '#00ffcc';
        ctx.fillStyle = '#0a0a0a';
        ctx.fill();
        ctx.shadowBlur = 0;

        // ラインの描画と寿命管理
        lines.forEach((line, index) => {
            ctx.beginPath();
            ctx.strokeStyle = `rgba(255, 255, 255, ${line.life})`;
            ctx.lineWidth = 3;
            line.points.forEach((p, i) => {
                if (i === 0) ctx.moveTo(p.x, p.y);
                else ctx.lineTo(p.x, p.y);
            });
            ctx.stroke();
            line.life -= 0.02;
            if (line.life <= 0) lines.splice(index, 1);
        });

        // 敵の生成
        if (Math.random() < 0.03 + (score / 10000)) {
            const angle = Math.random() * Math.PI * 2;
            const dist = Math.max(canvas.width, canvas.height);
            enemies.push({
                x: core.x + Math.cos(angle) * dist,
                y: core.y + Math.sin(angle) * dist,
                vx: -Math.cos(angle) * (2 + Math.random() * 2),
                vy: -Math.sin(angle) * (2 + Math.random() * 2),
                r: 5
            });
        }

        // 敵の移動と判定
        enemies.forEach((e, ei) => {
            e.x += e.vx;
            e.y += e.vy;
            ctx.fillStyle = '#ff3366';
            ctx.beginPath();
            ctx.arc(e.x, e.y, e.r, 0, Math.PI * 2);
            ctx.fill();

            // ラインとの衝突判定
            lines.forEach(line => {
                for (let i = 0; i < line.points.length - 1; i++) {
                    if (distToSegment(e, line.points[i], line.points[i+1]) < e.r + 5) {
                        e.vx *= -1.2; e.vy *= -1.2; // 跳ね返す
                        score += 10;
                        scoreDisp.innerText = score;
                    }
                }
            });

            // コアとの衝突判定
            const distToCore = Math.hypot(e.x - core.x, e.y - core.y);
            if (distToCore < core.r + e.r) gameOver();

            if (Math.abs(e.x) > 3000 || Math.abs(e.y) > 3000) enemies.splice(ei, 1);
        });

        requestAnimationFrame(loop);
    }

    function distToSegment(p, v, w) {
        const l2 = Math.hypot(v.x - w.x, v.y - w.y) ** 2;
        if (l2 === 0) return Math.hypot(p.x - v.x, p.y - v.y);
        let t = ((p.x - v.x) * (w.x - v.x) + (p.y - v.y) * (w.y - v.y)) / l2;
        t = Math.max(0, Math.min(1, t));
        return Math.hypot(p.x - (v.x + t * (w.x - v.x)), p.y - (v.y + t * (w.y - v.y)));
    }

    function gameOver() {
        gameActive = false;
        overlay.style.display = 'flex';
        overlay.querySelector('h1').innerText = "CORE DESTROYED";
        overlay.querySelector('p').innerText = `FINAL SCORE: ${score}`;
    }

    canvas.addEventListener('mousedown', (e) => { isDrawing = true; currentLine = [{x: e.clientX, y: e.clientY}]; });
    canvas.addEventListener('mousemove', (e) => {
        if (!isDrawing) return;
        currentLine.push({x: e.clientX, y: e.clientY});
        if (currentLine.length > 10) currentLine.shift();
    });
    window.addEventListener('mouseup', () => {
        if (isDrawing && currentLine.length > 1) lines.push({points: [...currentLine], life: 1.0});
        isDrawing = false;
    });

    canvas.addEventListener('touchstart', (e) => { 
        isDrawing = true; 
        currentLine = [{x: e.touches[0].clientX, y: e.touches[0].clientY}]; 
    });
    canvas.addEventListener('touchmove', (e) => {
        if (!isDrawing) return;
        currentLine.push({x: e.touches[0].clientX, y: e.touches[0].clientY});
        if (currentLine.length > 10) currentLine.shift();
    });
    window.addEventListener('touchend', () => {
        if (isDrawing && currentLine.length > 1) lines.push({points: [...currentLine], life: 1.0});
        isDrawing = false;
    });

    init();
</script>
</body>
</html>
