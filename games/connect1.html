<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>カラフル・コネクト</title>
    <meta name="google-adsense-account" content="ca-pub-3571574988222927">
    <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3571574988222927" crossorigin="anonymous"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.1/css/all.min.css">
    <style>
        body { margin: 0; background: #1a1a1a; font-family: sans-serif; display: flex; flex-direction: column; align-items: center; height: 100vh; overflow: hidden; touch-action: none; }
        #ui { padding: 20px; color: white; text-align: center; }
        #grid-container { background: #333; border: 5px solid #444; border-radius: 10px; position: relative; }
        canvas { display: block; cursor: crosshair; }
        .controls { margin-top: 20px; display: flex; gap: 10px; }
        .btn { padding: 10px 20px; border-radius: 5px; border: none; font-weight: bold; cursor: pointer; }
        #reset-btn { background: #555; color: white; }
        #overlay { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.8); display: none; flex-direction: column; align-items: center; justify-content: center; color: white; z-index: 100; }
    </style>
</head>
<body>

    <div id="ui">
        <h1>LEVEL <span id="level-num">1</span></h1>
        <p>同じ色のドットを繋ごう！</p>
    </div>

    <div id="grid-container">
        <canvas id="gameCanvas"></canvas>
    </div>

    <div class="controls">
        <button id="reset-btn" class="btn" onclick="resetLevel()">やり直し</button>
    </div>

    <div id="overlay">
        <h2 id="msg">CLEAR!</h2>
        <button id="next-action-btn" class="btn" style="background:#2ecc71; color:white;" onclick="goToNextLevel()">NEXT LEVEL</button>
        <a href="../index.html" style="color:#aaa; margin-top:20px; text-decoration:none;">一覧に戻る</a>
    </div>

<script>
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    const gridSize = 5;
    const cellSize = 60;
    canvas.width = gridSize * cellSize;
    canvas.height = gridSize * cellSize;

    // --- レベルデータ ---
    const LEVELS = [
        { dots: [
            { color: '#e74c3c', p1: {x:0, y:0}, p2: {x:4, y:0} },
            { color: '#3498db', p1: {x:0, y:1}, p2: {x:4, y:4} },
            { color: '#2ecc71', p1: {x:1, y:1}, p2: {x:1, y:4} }
        ]},
        { dots: [
            { color: '#f1c40f', p1: {x:0, y:0}, p2: {x:0, y:4} },
            { color: '#9b59b6', p1: {x:1, y:0}, p2: {x:4, y:0} },
            { color: '#e67e22', p1: {x:2, y:2}, p2: {x:4, y:4} }
        ]},
        { dots: [
            { color: '#1abc9c', p1: {x:0, y:0}, p2: {x:4, y:4} },
            { color: '#34495e', p1: {x:4, y:0}, p2: {x:0, y:4} },
            { color: '#e74c3c', p1: {x:2, y:0}, p2: {x:2, y:4} }
        ]}
    ];

    let currentLevelIndex = parseInt(localStorage.getItem('connect_game_level') || 0);
    if (currentLevelIndex >= LEVELS.length) currentLevelIndex = 0; // 全クリア後は最初に戻る

    let dots = LEVELS[currentLevelIndex].dots;
    let paths = dots.map(() => []);
    let isDrawing = false;
    let currentColorIndex = -1;

    function initLevel() {
        document.getElementById('level-num').innerText = currentLevelIndex + 1;
        document.getElementById('overlay').style.display = 'none';
        dots = LEVELS[currentLevelIndex].dots;
        paths = dots.map(() => []);
        draw();
    }

    function draw() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        ctx.strokeStyle = '#444';
        ctx.lineWidth = 1;
        for(let i=0; i<=gridSize; i++) {
            ctx.beginPath(); ctx.moveTo(i*cellSize, 0); ctx.lineTo(i*cellSize, canvas.height); ctx.stroke();
            ctx.beginPath(); ctx.moveTo(0, i*cellSize); ctx.lineTo(canvas.width, i*cellSize); ctx.stroke();
        }
        paths.forEach((path, idx) => {
            if (path.length < 1) return;
            ctx.strokeStyle = dots[idx].color;
            ctx.lineWidth = 15;
            ctx.lineCap = 'round';
            ctx.lineJoin = 'round';
            ctx.beginPath();
            ctx.moveTo(path[0].x * cellSize + cellSize/2, path[0].y * cellSize + cellSize/2);
            for(let i=1; i<path.length; i++) {
                ctx.lineTo(path[i].x * cellSize + cellSize/2, path[i].y * cellSize + cellSize/2);
            }
            ctx.stroke();
        });
        dots.forEach(dot => {
            ctx.fillStyle = dot.color;
            [dot.p1, dot.p2].forEach(p => {
                ctx.beginPath();
                ctx.arc(p.x * cellSize + cellSize/2, p.y * cellSize + cellSize/2, 20, 0, Math.PI*2);
                ctx.fill();
            });
        });
    }

    function getMousePos(e) {
        const rect = canvas.getBoundingClientRect();
        const clientX = e.touches ? e.touches[0].clientX : e.clientX;
        const clientY = e.touches ? e.touches[0].clientY : e.clientY;
        return {
            x: Math.floor((clientX - rect.left) / (rect.width / gridSize)),
            y: Math.floor((clientY - rect.top) / (rect.height / gridSize))
        };
    }

    function start(e) {
        const pos = getMousePos(e);
        dots.forEach((dot, idx) => {
            if ((pos.x === dot.p1.x && pos.y === dot.p1.y) || (pos.x === dot.p2.x && pos.y === dot.p2.y)) {
                isDrawing = true;
                currentColorIndex = idx;
                paths[idx] = [pos];
            }
        });
    }

    function move(e) {
        if (!isDrawing) return;
        const pos = getMousePos(e);
        if (pos.x < 0 || pos.x >= gridSize || pos.y < 0 || pos.y >= gridSize) return;
        
        const path = paths[currentColorIndex];
        const lastPos = path[path.length - 1];
        
        if (pos.x !== lastPos.x || pos.y !== lastPos.y) {
            if (Math.abs(pos.x - lastPos.x) + Math.abs(pos.y - lastPos.y) === 1) {
                // 他の色のドット（終点以外）を跨がないチェックなどは簡易化
                path.push(pos);
                draw();
                checkClear();
            }
        }
    }

    function end() { isDrawing = false; }

    function checkClear() {
        const cleared = dots.every((dot, idx) => {
            const p = paths[idx];
            if (p.length < 2) return false;
            const s = p[0], e = p[p.length-1];
            return (s.x === dot.p1.x && s.y === dot.p1.y && e.x === dot.p2.x && e.y === dot.p2.y) ||
                   (s.x === dot.p2.x && s.y === dot.p2.y && e.x === dot.p1.x && e.y === dot.p1.y);
        });
        if (cleared) {
            if (currentLevelIndex === LEVELS.length - 1) {
                document.getElementById('msg').innerText = "ALL STAGES CLEAR!";
                document.getElementById('next-action-btn').innerText = "最初から遊ぶ";
            }
            document.getElementById('overlay').style.display = 'flex';
        }
    }

    function resetLevel() { paths = dots.map(() => []); draw(); }
    
    function goToNextLevel() {
        currentLevelIndex++;
        if (currentLevelIndex >= LEVELS.length) currentLevelIndex = 0;
        localStorage.setItem('connect_game_level', currentLevelIndex);
        initLevel();
    }

    canvas.addEventListener('mousedown', start);
    window.addEventListener('mousemove', move);
    window.addEventListener('mouseup', end);
    canvas.addEventListener('touchstart', start);
    window.addEventListener('touchmove', move);
    window.addEventListener('touchend', end);

    initLevel();
</script>
</body>
</html>
