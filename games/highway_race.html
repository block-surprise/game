<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>ハイウェイ・ドリフター</title>
    <style>
        body { margin: 0; background: #333; font-family: sans-serif; overflow: hidden; touch-action: none; display: flex; flex-direction: column; align-items: center; }
        #game-ui { position: absolute; top: 20px; color: white; text-align: center; font-size: 1.5rem; font-weight: bold; text-shadow: 2px 2px #000; pointer-events: none; z-index: 10; }
        canvas { display: block; background: #555; box-shadow: 0 0 20px rgba(0,0,0,0.5); }
        #overlay { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.8); display: none; flex-direction: column; align-items: center; justify-content: center; color: white; z-index: 100; }
        .btn { background: #f39c12; color: white; border: none; padding: 15px 40px; border-radius: 30px; font-size: 1.2rem; cursor: pointer; margin-top: 20px; text-decoration: none; font-weight: bold; }
    </style>
</head>
<body>

    <div id="game-ui">走行距離: <span id="distance">0</span>m</div>
    <canvas id="canvas"></canvas>

    <div id="overlay">
        <h1 style="color: #e74c3c;">クラッシュ！</h1>
        <p>記録: <span id="final-distance">0</span> メートル</p>
        <button class="btn" onclick="location.reload()">再挑戦</button>
        <a href="/" class="btn" style="background: #7f8c8d;">一覧に戻る</a>
    </div>

<script>
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');
    canvas.width = Math.min(window.innerWidth, 400);
    canvas.height = window.innerHeight;

    const LANE_WIDTH = canvas.width / 3;
    let distance = 0;
    let speed = 5;
    let isGameOver = false;

    // プレイヤーの車
    const player = { lane: 1, y: canvas.height - 120, width: 50, height: 80, color: '#e74c3c' };

    // 敵の車
    let enemies = [];
    function spawnEnemy() {
        const lane = Math.floor(Math.random() * 3);
        enemies.push({ x: lane * LANE_WIDTH + (LANE_WIDTH - 50) / 2, y: -100, width: 50, height: 80, color: '#3498db' });
    }

    // 操作
    window.addEventListener('mousedown', (e) => {
        if (e.clientX < canvas.offsetLeft + canvas.width / 2) { if(player.lane > 0) player.lane--; }
        else { if(player.lane < 2) player.lane++; }
    });
    window.addEventListener('touchstart', (e) => {
        const touchX = e.touches[0].clientX;
        if (touchX < canvas.offsetLeft + canvas.width / 2) { if(player.lane > 0) player.lane--; }
        else { if(player.lane < 2) player.lane++; }
    });

    let frame = 0;
    function update() {
        if (isGameOver) return;

        frame++;
        distance += Math.floor(speed / 2);
        document.getElementById('distance').innerText = distance;
        
        if (frame % 60 === 0) spawnEnemy();
        if (frame % 500 === 0) speed += 1; // 徐々に加速

        enemies.forEach((en, index) => {
            en.y += speed;
            // 当たり判定
            const px = player.lane * LANE_WIDTH + (LANE_WIDTH - 50) / 2;
            if (px < en.x + en.width && px + player.width > en.x &&
                player.y < en.y + en.height && player.y + player.height > en.y) {
                isGameOver = true;
                document.getElementById('final-distance').innerText = distance;
                document.getElementById('overlay').style.display = 'flex';
            }
            // 画面外に出たら削除
            if (en.y > canvas.height) enemies.splice(index, 1);
        });
    }

    function draw() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);

        // 道路のライン
        ctx.strokeStyle = '#fff';
        ctx.setLineDash([20, 20]);
        ctx.beginPath();
        ctx.moveTo(LANE_WIDTH, 0); ctx.lineTo(LANE_WIDTH, canvas.height);
        ctx.moveTo(LANE_WIDTH * 2, 0); ctx.lineTo(LANE_WIDTH * 2, canvas.height);
        ctx.stroke();

        // プレイヤー
        const px = player.lane * LANE_WIDTH + (LANE_WIDTH - player.width) / 2;
        ctx.fillStyle = player.color;
        ctx.fillRect(px, player.y, player.width, player.height);
        ctx.fillStyle = '#000'; // 窓
        ctx.fillRect(px + 5, player.y + 10, 40, 20);

        // 敵
        enemies.forEach(en => {
            ctx.fillStyle = en.color;
            ctx.fillRect(en.x, en.y, en.width, en.height);
            ctx.fillStyle = '#000';
            ctx.fillRect(en.x + 5, en.y + 50, 40, 20);
        });

        requestAnimationFrame(() => { update(); draw(); });
    }

    draw();
</script>
</body>
</html>
